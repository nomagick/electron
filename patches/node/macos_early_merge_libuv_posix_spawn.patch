From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "yanlong.wang" <yanlong.wang@naiver.org>
Date: Tue, 31 Aug 2021 16:12:22 +0800
Subject: fix: darwin libuv use posix_spawn

Early merge the "posix spawn, take 2" just for electron v14

diff --git a/deps/uv/src/unix/process.c b/deps/uv/src/unix/process.c
index 8f94c53b249978c8ce41dc2447facbbcf585120a..a96c0197b9af5680edd0680bc447835dfd0ad3dc 100644
--- a/deps/uv/src/unix/process.c
+++ b/deps/uv/src/unix/process.c
@@ -26,6 +26,7 @@
 #include <stdlib.h>
 #include <assert.h>
 #include <errno.h>
+#include <string.h>
 
 #include <sys/types.h>
 #include <sys/wait.h>
@@ -34,8 +35,21 @@
 #include <poll.h>
 
 #if defined(__APPLE__) && !TARGET_OS_IPHONE
+# include <spawn.h>
+# include <paths.h>
+# include <sys/kauth.h>
+# include <sys/types.h>
+# include <sys/sysctl.h>
+# include <sys/syscall.h>
+# include <dlfcn.h>
 # include <crt_externs.h>
 # define environ (*_NSGetEnviron())
+
+/* macOS 10.14 back does not define this constant */
+# ifndef POSIX_SPAWN_SETSID
+#  define POSIX_SPAWN_SETSID 1024
+# endif
+
 #else
 extern char **environ;
 #endif
@@ -44,6 +58,10 @@ extern char **environ;
 # include <grp.h>
 #endif
 
+#if defined(__MVS__)
+# include "zos-base.h"
+#endif
+
 
 static void uv__chld(uv_signal_t* handle, int signum) {
   uv_process_t* process;
@@ -197,6 +215,12 @@ static void uv__write_int(int fd, int val) {
 }
 
 
+static void uv__write_errno(int error_fd) {
+  uv__write_int(error_fd, UV__ERR(errno));
+  _exit(127);
+}
+
+
 #if !(defined(__APPLE__) && (TARGET_OS_TV || TARGET_OS_WATCH))
 /* execvp is marked __WATCHOS_PROHIBITED __TVOS_PROHIBITED, so must be
  * avoided. Since this isn't called on those targets, the function
@@ -225,10 +249,8 @@ static void uv__process_child_init(const uv_process_options_t* options,
     if (use_fd < 0 || use_fd >= fd)
       continue;
     pipes[fd][1] = fcntl(use_fd, F_DUPFD, stdio_count);
-    if (pipes[fd][1] == -1) {
-      uv__write_int(error_fd, UV__ERR(errno));
-      _exit(127);
-    }
+    if (pipes[fd][1] == -1)
+      uv__write_errno(error_fd);
   }
 
   for (fd = 0; fd < stdio_count; fd++) {
@@ -245,10 +267,8 @@ static void uv__process_child_init(const uv_process_options_t* options,
         use_fd = open("/dev/null", fd == 0 ? O_RDONLY : O_RDWR);
         close_fd = use_fd;
 
-        if (use_fd < 0) {
-          uv__write_int(error_fd, UV__ERR(errno));
-          _exit(127);
-        }
+        if (use_fd < 0)
+          uv__write_errno(error_fd);
       }
     }
 
@@ -257,10 +277,8 @@ static void uv__process_child_init(const uv_process_options_t* options,
     else
       fd = dup2(use_fd, fd);
 
-    if (fd == -1) {
-      uv__write_int(error_fd, UV__ERR(errno));
-      _exit(127);
-    }
+    if (fd == -1)
+      uv__write_errno(error_fd);
 
     if (fd <= 2)
       uv__nonblock_fcntl(fd, 0);
@@ -276,10 +294,8 @@ static void uv__process_child_init(const uv_process_options_t* options,
       uv__close(use_fd);
   }
 
-  if (options->cwd != NULL && chdir(options->cwd)) {
-    uv__write_int(error_fd, UV__ERR(errno));
-    _exit(127);
-  }
+  if (options->cwd != NULL && chdir(options->cwd))
+    uv__write_errno(error_fd);
 
   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
     /* When dropping privileges from root, the `setgroups` call will
@@ -292,19 +308,14 @@ static void uv__process_child_init(const uv_process_options_t* options,
     SAVE_ERRNO(setgroups(0, NULL));
   }
 
-  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
-    uv__write_int(error_fd, UV__ERR(errno));
-    _exit(127);
-  }
+  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid))
+    uv__write_errno(error_fd);
 
-  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
-    uv__write_int(error_fd, UV__ERR(errno));
-    _exit(127);
-  }
+  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid))
+    uv__write_errno(error_fd);
 
-  if (options->env != NULL) {
+  if (options->env != NULL)
     environ = options->env;
-  }
 
   /* Reset signal disposition.  Use a hard-coded limit because NSIG
    * is not fixed on Linux: it's either 32, 34 or 64, depending on
@@ -323,25 +334,503 @@ static void uv__process_child_init(const uv_process_options_t* options,
     if (SIG_ERR != signal(n, SIG_DFL))
       continue;
 
-    uv__write_int(error_fd, UV__ERR(errno));
-    _exit(127);
+    uv__write_errno(error_fd);
   }
 
   /* Reset signal mask. */
   sigemptyset(&set);
   err = pthread_sigmask(SIG_SETMASK, &set, NULL);
 
+  if (err != 0)
+    uv__write_errno(error_fd);
+
+#ifdef __MVS__
+  execvpe(options->file, options->args, environ);
+#else
+  execvp(options->file, options->args);
+#endif
+
+  uv__write_errno(error_fd);
+}
+#endif
+
+
+#if defined(__APPLE__)
+typedef struct uv__posix_spawn_fncs_tag {
+  struct {
+    int (*addchdir_np)(const posix_spawn_file_actions_t *, const char *);
+  } file_actions;
+} uv__posix_spawn_fncs_t;
+
+
+static uv_once_t posix_spawn_init_once = UV_ONCE_INIT;
+static uv__posix_spawn_fncs_t posix_spawn_fncs;
+static int posix_spawn_can_use_setsid;
+
+static int uv__change_current_thread_directory(const char* path) {
+  // Changes the current thread's directory to a path or directory file
+  // descriptor. libpthread only exposes a syscall wrapper starting in
+  // macOS 10.12, but the system call dates back to macOS 10.5. On older OSes,
+  // the syscall is issued directly.
+  if (__builtin_available(macOS 10.12, *)) {
+    return pthread_chdir_np(path);
+  } else {
+    return syscall(SYS___pthread_chdir, path);
+  }
+}
+
+// The recommended way to unset a per-thread cwd is to set a new value to an
+// invalid file descriptor, per libpthread-218.1.3/private/private.h.
+static int uv__reset_current_thread_directory() {
+  if (__builtin_available(macOS 10.12, *)) {
+    return pthread_fchdir_np(-1);
+  } else {
+    return syscall(SYS___pthread_fchdir, -1);
+  }
+}
+
+
+void uv__spawn_init_posix_spawn_fncs(void) {
+  /* Try to locate all non-portable functions at runtime */
+  posix_spawn_fncs.file_actions.addchdir_np =
+    dlsym(RTLD_DEFAULT, "posix_spawn_file_actions_addchdir_np");
+}
+
+
+void uv__spawn_init_can_use_setsid(void) {
+  static const int MACOS_CATALINA_VERSION_MAJOR = 19;
+  char version_str[256];
+  char* version_major_str;
+  size_t version_str_size = 256;
+  int r;
+  int version_major;
+
+  /* By default, assume failure */
+  posix_spawn_can_use_setsid = 0;
+
+  /* Get a version string */
+  r = sysctlbyname("kern.osrelease", version_str, &version_str_size, NULL, 0);
+  if (r != 0)
+    return;
+
+  /* Try to get the major version number. If not found
+   * fall back to the fork/exec flow */
+  version_major_str = strtok(version_str, ".");
+  if (version_major_str == NULL)
+    return;
+
+  /* Parse the version major as a number. If it is greater than
+   * the major version for macOS Catalina (aka macOS 10.15), then
+   * the POSIX_SPAWN_SETSID flag is available */
+  version_major = atoi(version_major_str);
+  if (version_major >= MACOS_CATALINA_VERSION_MAJOR)
+    posix_spawn_can_use_setsid = 1;
+}
+
+
+void uv__spawn_init_posix_spawn(void) {
+  /* Init handles to all potentially non-defined functions */
+  uv__spawn_init_posix_spawn_fncs();
+
+  /* Init feature detection for POSIX_SPAWN_SETSID flag */
+  uv__spawn_init_can_use_setsid();
+}
+
+
+int uv__spawn_set_posix_spawn_attrs(posix_spawnattr_t* attrs,
+                                    const uv__posix_spawn_fncs_t* posix_spawn_fncs,
+                                    const uv_process_options_t* options) {
+  int err;
+  unsigned int flags;
+  sigset_t signal_set;
+
+  err = posix_spawnattr_init(attrs);
   if (err != 0) {
-    uv__write_int(error_fd, UV__ERR(err));
-    _exit(127);
+    /* If initialization fails, no need to de-init, just return */
+    return err;
   }
 
-  execvp(options->file, options->args);
-  uv__write_int(error_fd, UV__ERR(errno));
-  _exit(127);
+  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
+      /* kauth_cred_issuser currently requires exactly uid == 0 for these
+       * posixspawn_attrs (set_groups_np, setuid_np, setgid_np), which deviates
+       * from the normal specification of setuid (which also uses euid), and
+       * they are also undocumented syscalls, so we do not use them. */
+    err = ENOSYS;
+    goto error;
+  }
+
+  /* Set flags for spawn behavior
+    * 1) POSIX_SPAWN_CLOEXEC_DEFAULT: (Apple Extension) All descriptors in
+    * the parent will be treated as if they had been created with O_CLOEXEC.
+    * The only fds that will be passed on to the child are those manipulated
+    * by the file actions
+    * 2) POSIX_SPAWN_SETSIGDEF: Signals mentioned in spawn-sigdefault in
+    * the spawn attributes will be reset to behave as their default
+    * 3) POSIX_SPAWN_SETSIGMASK: Signal mask will be set to the value of
+    * spawn-sigmask in attributes
+    * 4) POSIX_SPAWN_SETSID: Make the process a new session leader if a
+    * detached session was requested. */
+  flags = POSIX_SPAWN_CLOEXEC_DEFAULT |
+          POSIX_SPAWN_SETSIGDEF |
+          POSIX_SPAWN_SETSIGMASK;
+  if (options->flags & UV_PROCESS_DETACHED) {
+    /* If running on a version of macOS where this flag is not supported,
+     * revert back to the fork/exec flow. Otherwise posix_spawn will
+     * silently ignore the flag. */
+    if (!posix_spawn_can_use_setsid) {
+      err = ENOSYS;
+      goto error;
+    }
+
+    flags |= POSIX_SPAWN_SETSID;
+  }
+  err = posix_spawnattr_setflags(attrs, flags);
+  if (err != 0)
+    goto error;
+
+  /*  Reset all signal the child to their default behavior */
+  sigfillset(&signal_set);
+  err = posix_spawnattr_setsigdefault(attrs, &signal_set);
+  if (err != 0)
+    goto error;
+
+  /*  Reset the signal mask for all signals */
+  sigemptyset(&signal_set);
+  err = posix_spawnattr_setsigmask(attrs, &signal_set);
+  if (err != 0)
+    goto error;
+
+  return err;
+
+error:
+  (void) posix_spawnattr_destroy(attrs);
+  return err;
+}
+
+
+int uv__spawn_set_posix_spawn_file_actions(posix_spawn_file_actions_t* actions,
+                                           const uv__posix_spawn_fncs_t* posix_spawn_fncs,
+                                           const uv_process_options_t* options,
+                                           int stdio_count,
+                                           int (*pipes)[2]) {
+  int fd;
+  int err;
+
+  err = posix_spawn_file_actions_init(actions);
+  if (err != 0) {
+    /* If initialization fails, no need to de-init, just return */
+    return err;
+  }
+
+  /* Set the current working directory if requested */
+  if (options->cwd != NULL) {
+    if (strchr(options->file, '/') != NULL) {
+      /* There is a bug in macOS where a relative executable
+       * path like "../myprogram" will cause `posix_spawnp` to
+       * successfully launch the program, but erroneously return
+       * ENOENT when used with posix_spawn_file_actions_addchdir_np
+       * because of the stat call performed on the executable path
+       * which was introduced in macOS 10.15.
+       * Ref: https://opensource.apple.com/source/Libc/Libc-1439.40.11/sys/posix_spawn.c.auto.html */
+      err = uv__change_current_thread_directory(options->cwd);
+    } else {
+      if (posix_spawn_fncs->file_actions.addchdir_np == NULL) {
+        err = ENOSYS;
+        goto error;
+      }
+      err = posix_spawn_fncs->file_actions.addchdir_np(actions, options->cwd);
+    }
+    if (err != 0)
+      goto error;
+  }
+
+  /* First, duplicate any required fd into orbit, out of the range of
+   * the descriptors that should be mapped in. */
+  for (fd = 0; fd < stdio_count; fd++) {
+    if (pipes[fd][1] < 0)
+      continue;
+
+    err = posix_spawn_file_actions_adddup2(
+      actions,
+      pipes[fd][1],
+      stdio_count + fd);
+    if (err != 0)
+      goto error;
+  }
+
+  /*  Second, move the descriptors into their respective places */
+  for (fd = 0; fd < stdio_count; fd++) {
+    if (pipes[fd][1] < 0)
+      continue;
+
+    err = posix_spawn_file_actions_adddup2(actions, stdio_count + fd, fd);
+    if (err != 0)
+      goto error;
+  }
+
+  /*  Finally, close all the superfluous descriptors */
+  for (fd = 0; fd < stdio_count; fd++) {
+    if (pipes[fd][1] < 0)
+      continue;
+
+    err = posix_spawn_file_actions_addclose(actions, stdio_count + fd);
+    if (err != 0)
+      goto error;
+  }
+
+  /*  Finally process the standard streams as per documentation */
+  for (fd = 0; fd < 3; fd++) {
+    int oflags;
+    const int mode = 0;
+
+    oflags = fd == 0 ? O_RDONLY : O_RDWR;
+
+    if (pipes[fd][1] != -1) {
+      /* If not ignored, make sure the fd is marked as non-blocking */
+      uv__nonblock_fcntl(pipes[fd][1], 0);
+    } else {
+      /* If ignored, redirect to (or from) /dev/null, */
+      err = posix_spawn_file_actions_addopen(
+        actions,
+        fd,
+        "/dev/null",
+        oflags,
+        mode);
+      if (err != 0)
+        goto error;
+    }
+  }
+
+  return 0;
+
+error:
+  (void) posix_spawn_file_actions_destroy(actions);
+  return err;
+}
+
+char* uv__spawn_find_path_in_env(char** env) {
+  char** env_iterator;
+  const char path_var[] = "PATH=";
+
+  /* Look for an environment variable called PATH in the
+   * provided env array, and return its value if found */
+  for (env_iterator = env; *env_iterator != NULL; env_iterator++) {
+    if (strncmp(*env_iterator, path_var, sizeof(path_var) - 1) == 0) {
+      /* Found "PATH=" at the beginning of the string */
+      return *env_iterator + sizeof(path_var) - 1;
+    }
+  }
+
+  return NULL;
 }
+
+
+int uv__spawn_resolve_and_spawn(const uv_process_options_t* options,
+                                posix_spawnattr_t* attrs,
+                                posix_spawn_file_actions_t* actions,
+                                pid_t* pid) {
+  const char *p;
+  const char *z;
+  const char *path;
+  size_t l;
+  size_t k;
+  int err;
+  int seen_eacces;
+
+  path = NULL;
+  err = -1;
+  seen_eacces = 0;
+
+  /* Short circuit for erroneous case */
+  if (options->file == NULL)
+    return ENOENT;
+
+  /* The environment for the child process is that of the parent unless overriden
+   * by options->env */
+  char** env = environ;
+  if (options->env != NULL)
+    env = options->env;
+
+  /* If options->file contains a slash, posix_spawn/posix_spawnp behave
+   * the same, and don't involve PATH resolution at all. Otherwise, if
+   * options->file does not include a slash, but no custom environment is
+   * to be used, the environment used for path resolution as well for the
+   * child process is that of the parent process, so posix_spawnp is the
+   * way to go. */
+  if (strchr(options->file, '/') != NULL || options->env == NULL) {
+    do
+      err = posix_spawnp(pid, options->file, actions, attrs, options->args, env);
+    while (err == EINTR);
+    /* Restore the thread's working directory if it was changed. */
+    if (options->cwd != NULL)
+      uv__reset_current_thread_directory();
+    return err;
+  }
+
+  /* Look for the definition of PATH in the provided env */
+  path = uv__spawn_find_path_in_env(options->env);
+
+  /* The following resolution logic (execvpe emulation) is copied from
+   * https://git.musl-libc.org/cgit/musl/tree/src/process/execvp.c
+   * and adapted to work for our specific usage */
+
+  /* If no path was provided in options->env, use the default value
+   * to look for the executable */
+  if (path == NULL)
+    path = _PATH_DEFPATH;
+
+  k = strnlen(options->file, NAME_MAX + 1);
+  if (k > NAME_MAX)
+    return ENAMETOOLONG;
+
+  l = strnlen(path, PATH_MAX - 1) + 1;
+
+  for (p = path;; p = z) {
+    /* Compose the new process file from the entry in the PATH
+     * environment variable and the actual file name */
+    char b[PATH_MAX + NAME_MAX];
+    z = strchr(p, ':');
+    if (!z)
+      z = p + strlen(p);
+    if ((size_t)(z - p) >= l) {
+      if (!*z++)
+        break;
+
+      continue;
+    }
+    memcpy(b, p, z - p);
+    b[z - p] = '/';
+    memcpy(b + (z - p) + (z > p), options->file, k + 1);
+
+    /* Try to spawn the new process file. If it fails with ENOENT, the
+     * new process file is not in this PATH entry, continue with the next
+     * PATH entry. */
+    do
+      err = posix_spawn(pid, b, actions, attrs, options->args, env);
+    while (err == EINTR);
+
+    switch (err) {
+    case EACCES:
+      seen_eacces = 1;
+      break; /* continue search */
+    case ENOENT:
+    case ENOTDIR:
+      break; /* continue search */
+    default:
+      return err;
+    }
+
+    if (!*z++)
+      break;
+  }
+
+  if (seen_eacces)
+    return EACCES;
+  return err;
+}
+
+
+int uv__spawn_and_init_child_posix_spawn(const uv_process_options_t* options,
+                                         int stdio_count,
+                                         int (*pipes)[2],
+                                         pid_t* pid,
+                                         const uv__posix_spawn_fncs_t* posix_spawn_fncs) {
+  int err;
+  posix_spawnattr_t attrs;
+  posix_spawn_file_actions_t actions;
+
+  err = uv__spawn_set_posix_spawn_attrs(&attrs, posix_spawn_fncs, options);
+  if (err != 0)
+    goto error;
+
+  err = uv__spawn_set_posix_spawn_file_actions(
+    &actions,
+    posix_spawn_fncs,
+    options,
+    stdio_count,
+    pipes);
+  if (err != 0) {
+    (void) posix_spawnattr_destroy(&attrs);
+    goto error;
+  }
+
+  /* Try to spawn options->file resolving in the provided environment
+   * if any */
+  err = uv__spawn_resolve_and_spawn(options, &attrs, &actions, pid);
+
+  /* Destroy the actions/attributes */
+  (void) posix_spawn_file_actions_destroy(&actions);
+  (void) posix_spawnattr_destroy(&attrs);
+
+error:
+  /* In an error situation, the attributes and file actions are
+   * already destroyed, only the happy path requires cleanup */
+  return UV__ERR(err);
+}
+#endif
+
+int uv__spawn_and_init_child_fork(const uv_process_options_t* options,
+                                  int stdio_count,
+                                  int (*pipes)[2],
+                                  int error_fd,
+                                  pid_t* pid) {
+  *pid = fork();
+
+  if (*pid == -1) {
+    /* Failed to fork */
+    return UV__ERR(errno);
+  }
+
+  if (*pid == 0) {
+    /* Fork succeeded, in the child process */
+    uv__process_child_init(options, stdio_count, pipes, error_fd);
+    abort();
+  }
+
+  /* Fork succeeded, in the parent process */
+  return 0;
+}
+
+int uv__spawn_and_init_child(const uv_process_options_t* options,
+                             int stdio_count,
+                             int (*pipes)[2],
+                             int error_fd,
+                             pid_t* pid) {
+  int err;
+
+#if defined(__APPLE__)
+  uv_once(&posix_spawn_init_once, uv__spawn_init_posix_spawn);
+
+  /* Special child process spawn case for macOS Big Sur (11.0) onwards
+   *
+   * Big Sur introduced a significant performance degradation on a call to
+   * fork/exec when the process has many pages mmaped in with MAP_JIT, like, say
+   * a javascript interpreter. Electron-based applications, for example,
+   * are impacted; though the magnitude of the impact depends on how much the
+   * app relies on subprocesses.
+   *
+   * On macOS, though, posix_spawn is implemented in a way that does not
+   * exhibit the problem. This block implements the forking and preparation
+   * logic with posix_spawn and its related primitives. It also takes advantage of
+   * the macOS extension POSIX_SPAWN_CLOEXEC_DEFAULT that makes impossible to
+   * leak descriptors to the child process. */
+  err = uv__spawn_and_init_child_posix_spawn(options,
+                                              stdio_count,
+                                              pipes,
+                                              pid,
+                                              &posix_spawn_fncs);
+
+  /* The posix_spawn flow will return UV_ENOSYS if any of the posix_spawn_x_np
+   * non-standard functions is both _needed_ and _undefined_. In those cases,
+   * default back to the fork/execve strategy. For all other errors, just fail. */
+  if (err != UV_ENOSYS)
+    return err;
+
 #endif
+  err = uv__spawn_and_init_child_fork(options, stdio_count, pipes, error_fd, pid);
 
+  return err;
+}
 
 int uv_spawn(uv_loop_t* loop,
              uv_process_t* process,
@@ -424,48 +913,45 @@ int uv_spawn(uv_loop_t* loop,
 
   /* Acquire write lock to prevent opening new fds in worker threads */
   uv_rwlock_wrlock(&loop->cloexec_lock);
-  pid = fork();
 
-  if (pid == -1) {
-    err = UV__ERR(errno);
-    uv_rwlock_wrunlock(&loop->cloexec_lock);
-    uv__close(signal_pipe[0]);
-    uv__close(signal_pipe[1]);
-    goto error;
-  }
-
-  if (pid == 0) {
-    uv__process_child_init(options, stdio_count, pipes, signal_pipe[1]);
-    abort();
-  }
+  /* Spawn the child */
+  exec_errorno = uv__spawn_and_init_child(options, stdio_count, pipes, signal_pipe[1], &pid);
 
   /* Release lock in parent process */
   uv_rwlock_wrunlock(&loop->cloexec_lock);
   uv__close(signal_pipe[1]);
 
-  process->status = 0;
-  exec_errorno = 0;
-  do
-    r = read(signal_pipe[0], &exec_errorno, sizeof(exec_errorno));
-  while (r == -1 && errno == EINTR);
-
-  if (r == 0)
-    ; /* okay, EOF */
-  else if (r == sizeof(exec_errorno)) {
-    do
-      err = waitpid(pid, &status, 0); /* okay, read errorno */
-    while (err == -1 && errno == EINTR);
-    assert(err == pid);
-  } else if (r == -1 && errno == EPIPE) {
+  if (exec_errorno == 0) {
     do
-      err = waitpid(pid, &status, 0); /* okay, got EPIPE */
-    while (err == -1 && errno == EINTR);
-    assert(err == pid);
-  } else
-    abort();
+      r = read(signal_pipe[0], &exec_errorno, sizeof(exec_errorno));
+    while (r == -1 && errno == EINTR);
+
+    if (r == 0)
+      ; /* okay, EOF */
+    else if (r == sizeof(exec_errorno)) {
+      do
+        err = waitpid(pid, &status, 0); /* okay, read errorno */
+      while (err == -1 && errno == EINTR);
+      assert(err == pid);
+    } else if (r == -1 && errno == EPIPE) {
+      do
+        err = waitpid(pid, &status, 0); /* okay, got EPIPE */
+      while (err == -1 && errno == EINTR);
+      assert(err == pid);
+    } else
+      abort();
+  }
 
   uv__close_nocheckstdio(signal_pipe[0]);
 
+#if 0
+  /* This runs into a nodejs issue (it expects initialized streams, even if the
+   * exec failed).
+   * See https://github.com/libuv/libuv/pull/3107#issuecomment-782482608 */
+  if (exec_errorno != 0)
+      goto error;
+#endif
+
   for (i = 0; i < options->stdio_count; i++) {
     err = uv__process_open_stream(options->stdio + i, pipes[i]);
     if (err == 0)
